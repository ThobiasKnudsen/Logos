#include "global_data/gpu/gpu_window.h"
#include "global_data/core.h"
#include <SDL3/SDL.h>

// this is the type key for the GPU_Window node type and should always be used when accessing GPU_Window nodes
static const char* g_gpu_window_type_key = "GPU_Window";


typedef struct GPU_Window {
    struct gd_base_node     base;
    SDL_Window*             p_sdl_window;
    bool                    device_key_is_number;
    gd_key                  gpu_device_key;
    SDL_ThreadID            thread_id;
} GPU_Window;

bool gpu_window_free(struct gd_base_node* node) {
    GPU_Window* p_gpu_window = caa_container_of(node, GPU_Window, base);
    if (p_gpu_window->p_sdl_window == NULL) {
        tklog_error("SDL_Window is NULL\n");
        return false;
    }
    SDL_DestroyWindow(p_gpu_window->p_sdl_window);
    free(p_gpu_window);
    return true;
}

void gpu_window_free_callback(struct rcu_head* rcu_head) {
    GPU_Window* p_gpu_window = caa_container_of(rcu_head, GPU_Window, base);
    SDL_DestroyWindow(p_gpu_window->p_sdl_window);
    tklog_scope(bool result = gpu_window_free(&p_gpu_window->base));
    if (!result) {
        tklog_error("Failed to free gpu_window\n");
    }
}

bool gpu_window_is_valid(struct gd_base_node* node) {
    GPU_Window* p_gpu_window = caa_container_of(node, GPU_Window, base);
    if (p_gpu_window->p_sdl_window == NULL) {
        tklog_notice("SDL_Window is NULL\n");
        return false;
    }
    rcu_read_lock();
    tklog_scope(struct gd_base_node* p_gpu_device = gd_get_node_unsafe(p_gpu_window->gpu_device_key, p_gpu_window->device_key_is_number));
    if (p_gpu_device == NULL) {
        tklog_notice("GPU device not found\n");
        return false;
    }
    rcu_read_unlock();
    return true;
}

void gpu_window_type_init() {
    if (g_gpu_window_type_key != NULL) {
        tklog_error("GPU_Window type already initialized\n");
        return;
    }
    tklog_scope(union gd_key type_key = gd_create_key(0, g_gpu_window_type_key, false));
    tklog_scope(type_key = gd_create_node_type(type_key, false,
                                               sizeof(GPU_Window),
                                               gpu_window_free,
                                               gpu_window_free_callback,
                                               gpu_window_is_valid));
    if (type_key.string == NULL) {
        tklog_error("Failed to create gpu_window type\n");
        return;
    }
    tklog_info("Created gpu_window type with type_key: %s\n", g_gpu_window_type_key);
}

gd_key gpu_window_create(
    gd_key gpu_device_key,
    int width,
    int height,
    const char* title) 
{
    GPU_Window* p_gpu_window = (GPU_Window*)calloc(1, sizeof(GPU_Window));
    if (p_gpu_window == NULL) {
        tklog_error("Failed to allocate memory for gpu_window\n");
        return (union gd_key){ .number = 0 };
    }
    
    // Initialize the base node structure
    cds_lfht_node_init(&p_gpu_window->base.lfht_node);
    p_gpu_window->base.key_is_number = true;
    p_gpu_window->base.type_key_is_number = false;
    p_gpu_window->base.size_bytes = sizeof(GPU_Window);
    
    // Set up the key (auto-generate)
    p_gpu_window->base.key.number = 0; // Will be auto-generated by gd_insert
    
    // Set up the type key
    p_gpu_window->base.type_key.string = (char*)g_gpu_window_type_key;
    
    // Set up GPU window specific fields
    p_gpu_window->device_key_is_number = gpu_device_key.number != 0;
    p_gpu_window->gpu_device_key = gpu_device_key;
    p_gpu_window->thread_id = SDL_GetThreadID(NULL);
    
    // Create the SDL window
    p_gpu_window->p_sdl_window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_RESIZABLE);
    if (!p_gpu_window->p_sdl_window) {
        tklog_error("Failed to create SDL window: %s\n", SDL_GetError());
        free(p_gpu_window);
        return (union gd_key){ .number = 0 };
    }
    
    // Insert the node into the global data system
    tklog_scope(union gd_key result_key = gd_insert(&p_gpu_window->base));
    
    if (result_key.number == 0) {
        tklog_error("Failed to insert GPU window into global data system\n");
        SDL_DestroyWindow(p_gpu_window->p_sdl_window);
        free(p_gpu_window);
        return (union gd_key){ .number = 0 };
    }
    
    tklog_info("Successfully created GPU window with key %llu\n", result_key.number);
    return result_key;
}


























// ===============================================================================================================
// OLD VERSION OF WINDOW USING vec.c and type.c instead of global_data
// ===============================================================================================================
int cpi_Window_Create(
    int gpu_device_index,
    unsigned int width,
    unsigned int height,
    const char* title)
{
    if (!title) {
        tklog_warning("title is NULL");
        return -1;
    }


    tklog_scope(Vec** pp_window_vec = vec_MoveStart(g_vec));
    tklog_scope(vec_SwitchReadToWrite(*pp_window_vec));
    tklog_scope(int window_vec_index = vec_UpsertVecWithType_UnsafeWrite(*pp_window_vec, cpi_window_type));
    tklog_scope(vec_SwitchWriteToRead(*pp_window_vec));
    tklog_scope(vec_MoveToIndex(pp_window_vec, window_vec_index, cpi_window_type));
    tklog_scope(vec_SwitchReadToWrite(*pp_window_vec));
    tklog_scope(int window_index = vec_UpsertNullElement_UnsafeWrite(*pp_window_vec, cpi_window_type));
    tklog_scope(CPI_Window* p_window = (CPI_Window*)vec_GetElement_UnsafeRead(*pp_window_vec, window_index, cpi_window_type));
    if (!p_window) {
        tklog_critical("NULL pointer");
        return -1;
    }
    if (p_window->p_sdl_window) {
        tklog_critical("INTERNAL ERROR: sdl window should be NULL");
        return -1;
    }
    p_window->p_sdl_window = SDL_CreateWindow(title, width, height, SDL_WINDOW_RESIZABLE);
    if (!p_window->p_sdl_window) {
        tklog_critical("ERROR: failed to create window: %s", SDL_GetError());
        return -1;
    }

    // getting gpu device
    p_window->gpu_device_index = gpu_device_index;
    tklog_scope(Vec** pp_gpu_device_vec = vec_MoveStart(g_vec));
    tklog_scope(int gpu_device_vec_index = vec_UpsertVecWithType_UnsafeWrite(*pp_gpu_device_vec, cpi_gpu_device_type));
    tklog_scope(vec_MoveToIndex(pp_gpu_device_vec, gpu_device_vec_index, cpi_gpu_device_type));
    tklog_scope(CPI_GPUDevice* p_gpu_device = (CPI_GPUDevice*)vec_GetElement_UnsafeRead(*pp_gpu_device_vec, gpu_device_index, cpi_gpu_device_type));
    
    if (!p_gpu_device->p_gpu_device) {
        tklog_critical("NULL pointer");
        return -1;
    };

    if (!SDL_ClaimWindowForGPUDevice(p_gpu_device->p_gpu_device, p_window->p_sdl_window)) {
        tklog_error("Failed to claim window");
        return -1;
    }
    tklog_scope(vec_MoveEnd(pp_gpu_device_vec));

    #ifdef DEBUG
        SDL_LockMutex(g_unique_id_mutex);
        p_window->id = g_unique_id++;
        SDL_UnlockMutex(g_unique_id_mutex);
    #endif

    tklog_scope(vec_SwitchWriteToRead(*pp_window_vec));
    tklog_scope(vec_MoveEnd(pp_window_vec));

    printf("SUCCESSFULLY created window\n");
    return window_index;
}
void cpi_Window_Show(
    int window_index,
    int graphics_pipeline_index) 
{
    // get the window
    tklog_scope(Vec** pp_window_vec = vec_MoveStart(g_vec));
    tklog_scope(int window_vec_index = vec_GetVecWithType_UnsafeRead(*pp_window_vec, cpi_window_type));
    tklog_scope(vec_MoveToIndex(pp_window_vec, window_vec_index, cpi_window_type));
    tklog_scope(CPI_Window* p_window = (CPI_Window*)vec_GetElement_UnsafeRead(*pp_window_vec, window_index, cpi_window_type));
    tklog_scope(if (!p_window->p_sdl_window) {
        tklog_critical("NULL pointer");
        return;
    });

    // get the gpu device
    tklog_scope(Vec** pp_gpu_device_vec = vec_MoveStart(g_vec));
    tklog_scope(int gpu_device_vec_index = vec_GetVecWithType_UnsafeRead(*pp_gpu_device_vec, cpi_gpu_device_type));
    tklog_scope(vec_MoveToIndex(pp_gpu_device_vec, gpu_device_vec_index, cpi_gpu_device_type));
    tklog_scope(CPI_GPUDevice* p_gpu_device = (CPI_GPUDevice*)vec_GetElement_UnsafeRead(*pp_gpu_device_vec, p_window->gpu_device_index, cpi_gpu_device_type));
    tklog_scope(if (!p_gpu_device->p_gpu_device) {
        tklog_critical("NULL pointer");
        return;
    });

    SDL_GPUTextureFormat color_format = SDL_GetGPUSwapchainTextureFormat(p_gpu_device->p_gpu_device, p_window->p_sdl_window);
    if (SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM != color_format) {
        tklog_error("not correct color format");
        return;
    }

    // get the graphics pipeline
    tklog_scope(Vec** pp_graphics_pipeline_vec = vec_MoveStart(g_vec));
    tklog_scope(int gpu_graphics_pipeline_index = vec_GetVecWithType_UnsafeRead(*pp_graphics_pipeline_vec, cpi_graphics_pipeline_type));
    tklog_scope(vec_MoveToIndex(pp_graphics_pipeline_vec, gpu_graphics_pipeline_index, cpi_graphics_pipeline_type));
    tklog_scope(CPI_GraphicsPipeline* p_graphics_pipeline = (CPI_GraphicsPipeline*)vec_GetElement_UnsafeRead(*pp_graphics_pipeline_vec, graphics_pipeline_index, cpi_graphics_pipeline_type));
    tklog_scope(if (!p_graphics_pipeline->p_graphics_pipeline) {
        tklog_critical("NULL pointer");
        return;
    });

    Rect rects[2] = {
        { 
            .rect = { .x = 100.f, .y = 100.f, .w = 300.f, .h = 300.f },
            .rotation = 0.0f,
            .corner_radius_pixels = 20.f,
            .color = { .r = 200, .g = 200, .b = 200, .a = 255 },
            .tex_index = 1,
            .tex_rect = { .x = 0.0f, .y = 0.0f, .w = 1.0f, .h = 1.0f }
        }, { 
            .rect = { .x = 100.f, .y = 100.f, .w = 100.f, .h = 100.f },
            .rotation = 50.0f,
            .corner_radius_pixels = 20.f,
            .color = { .r = 200, .g = 200, .b = 200, .a = 100 },
            .tex_index = 0,
            .tex_rect = { .x = 0.0f, .y = 0.0f, .w = 1.0f, .h = 1.0f }
        }
    };
    unsigned int size = sizeof(rects);

    SDL_GPUTransferBufferCreateInfo transfer_info = {
        .usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD,
        .size = size
    };
    tklog_scope(SDL_GPUTransferBuffer* transfer_buffer = SDL_CreateGPUTransferBuffer(p_gpu_device->p_gpu_device, &transfer_info));
    if (!transfer_buffer) {
        tklog_critical("Failed to create transfer buffer: %s", SDL_GetError());
        return;
    }

    tklog_scope(void* mapped_data = SDL_MapGPUTransferBuffer(p_gpu_device->p_gpu_device, transfer_buffer, false));
    if (!mapped_data) {
        tklog_critical("Failed to map transfer buffer: %s", SDL_GetError());
        return;
    }
    memcpy(mapped_data, rects, size);
    tklog_scope(SDL_UnmapGPUTransferBuffer(p_gpu_device->p_gpu_device, transfer_buffer));
    SDL_GPUBufferCreateInfo buffer_create_info = {
        .usage = SDL_GPU_BUFFERUSAGE_VERTEX,
        .size = size
    };

    tklog_scope(SDL_GPUBuffer* gpu_buffer = SDL_CreateGPUBuffer(p_gpu_device->p_gpu_device, &buffer_create_info));
    if (!gpu_buffer) {
        tklog_critical("Failed to create GPU buffer: %s", SDL_GetError());
        return;
    }
    tklog_scope(SDL_GPUCommandBuffer* command_buffer = SDL_AcquireGPUCommandBuffer(p_gpu_device->p_gpu_device));
    if (!command_buffer) {
        tklog_critical("Failed to acquire command buffer: %s", SDL_GetError());
        return;
    }
    tklog_scope(SDL_GPUCopyPass* copy_pass = SDL_BeginGPUCopyPass(command_buffer));
    SDL_GPUTransferBufferLocation source = { transfer_buffer, 0 };
    SDL_GPUBufferRegion destination = { gpu_buffer, 0, size };
    tklog_scope(SDL_UploadToGPUBuffer(copy_pass, &source, &destination, false));
    tklog_scope(SDL_EndGPUCopyPass(copy_pass));
    if (!SDL_SubmitGPUCommandBuffer(command_buffer)) {
        tklog_critical("Failed to submit command buffer: %s", SDL_GetError());
        return;
    }
    SDL_ReleaseGPUTransferBuffer(p_gpu_device->p_gpu_device, transfer_buffer);

    // Load image using stb_image
    char absolute_path[PATH_MAX];
    if (!realpath("../resources/Bitcoin.png", absolute_path)) {
        tklog_error("realpath failed");
        return;
    }
    printf("Loading image from: %s\n", absolute_path);
    

    int width, height, channels;
    unsigned char* p_data = stbi_load("../resources/Bitcoin.png", &width, &height, &channels, STBI_rgb_alpha);
    if (!p_data) {
        tklog_error("Failed to load image file: %s", "../resources/Bitcoin.png");
        return;
    }
    
    // Create a bitcoin_texture with the dimensions of the loaded image.
    SDL_GPUTextureCreateInfo tex_info = {
        .type = SDL_GPU_TEXTURETYPE_2D,
        .format = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM,
        .usage = SDL_GPU_TEXTUREUSAGE_SAMPLER | SDL_GPU_TEXTUREUSAGE_COLOR_TARGET,
        .width = width,
        .height = height,
        .layer_count_or_depth = 1,
        .num_levels = 1,
        .sample_count = SDL_GPU_SAMPLECOUNT_1,
        .props = 0
    };
    SDL_GPUTexture* bitcoin_texture = SDL_CreateGPUTexture(p_gpu_device->p_gpu_device, &tex_info);
    if (!bitcoin_texture) {
        tklog_critical("Failed to create bitcoin_texture: %s", SDL_GetError());
        return;
    }
    
    // Create a transfer buffer sized to hold the entire image.
    size_t image_size = width * height * 4; // 4 bytes per pixel (RGBA)
    SDL_GPUTransferBufferCreateInfo tex_transfer_info = {
        .usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD,
        .size = image_size
    };
    SDL_GPUTransferBuffer* tex_transfer_buffer = SDL_CreateGPUTransferBuffer(p_gpu_device->p_gpu_device, &tex_transfer_info);
    if (!tex_transfer_buffer) {
        tklog_critical("Failed to create transfer buffer: %s", SDL_GetError());
        return;
    }
    
    // Map the transfer buffer and copy the image data into it.
    void* tex_map = SDL_MapGPUTransferBuffer(p_gpu_device->p_gpu_device, tex_transfer_buffer, false);
    if (!tex_map) {
        tklog_critical("Failed to map transfer buffer: %s", SDL_GetError());
        return;
    }
    memcpy(tex_map, p_data, image_size);
    SDL_UnmapGPUTransferBuffer(p_gpu_device->p_gpu_device, tex_transfer_buffer);
    
    // Define a bitcoin_texture region covering the entire bitcoin_texture.
    SDL_GPUTextureRegion tex_region = {
        .texture = bitcoin_texture,
        .mip_level = 0,
        .layer = 0,
        .x = 0,
        .y = 0,
        .w = width,
        .h = height,
        .d = 1
    };
    
    // Set up transfer info. Here, pixels_per_row and rows_per_layer match the image dimensions.
    SDL_GPUTextureTransferInfo tex_transfer = {
        .transfer_buffer = tex_transfer_buffer,
        .offset = 0,
        .pixels_per_row = width,
        .rows_per_layer = height
    };
    
    // Upload the bitcoin_texture data using a copy pass.
    SDL_GPUCommandBuffer* tex_cmd = SDL_AcquireGPUCommandBuffer(p_gpu_device->p_gpu_device);
    SDL_GPUCopyPass* tex_copy = SDL_BeginGPUCopyPass(tex_cmd);
    SDL_UploadToGPUTexture(tex_copy, &tex_transfer, &tex_region, false);
    SDL_EndGPUCopyPass(tex_copy);
    SDL_SubmitGPUCommandBuffer(tex_cmd);
    SDL_ReleaseGPUTransferBuffer(p_gpu_device->p_gpu_device, tex_transfer_buffer);
    
    // Create a bitcoin_sampler for the bitcoin_texture.
    SDL_GPUSamplerCreateInfo sampler_info = {
        .min_filter = SDL_GPU_FILTER_NEAREST,
        .mag_filter = SDL_GPU_FILTER_NEAREST,
        .mipmap_mode = SDL_GPU_SAMPLERMIPMAPMODE_NEAREST,
        .address_mode_u = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE,
        .address_mode_v = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE,
        .address_mode_w = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE,
        .mip_lod_bias = 0.0f,
        .max_anisotropy = 1.0f,
        .compare_op = SDL_GPU_COMPAREOP_ALWAYS,
        .min_lod = 0.0f,
        .max_lod = 0.0f,
        .enable_anisotropy = false,
        .enable_compare = false,
        .props = 0
    };
    SDL_GPUSampler* bitcoin_sampler = SDL_CreateGPUSampler(p_gpu_device->p_gpu_device, &sampler_info);
    if (!bitcoin_sampler) {
        tklog_critical("Failed to create bitcoin_sampler: %s", SDL_GetError());
        return;
    }
    
    // Free the loaded image data as it is now uploaded to the GPU.
    stbi_image_free(p_data);
    // --- Main rendering loop ---
    bool running = true;
    while (running) {
        // Process events (quit if window is closed)
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_EVENT_QUIT) {
                running = false;
            }
        }

        // Acquire a command buffer for the current frame.
        SDL_GPUCommandBuffer* cmd_buffer = SDL_AcquireGPUCommandBuffer(p_gpu_device->p_gpu_device);
        if (!cmd_buffer) {
            tklog_error("Failed to acquire command buffer: %s", SDL_GetError());
            return;
        }

        SDL_GPUTexture *swapchain_tex = NULL;
        unsigned int tex_width = 0, tex_height = 0;
        if (!SDL_WaitAndAcquireGPUSwapchainTexture(cmd_buffer, p_window->p_sdl_window, &swapchain_tex, &tex_width, &tex_height)) {
            tklog_error("Failed to acquire swapchain texture: %s", SDL_GetError());
            return;
        }

        // Create dummy UBO data (for the vertex shader's UBO in set 1).
        typedef struct {
            float targetWidth;
            float targetHeight;
            float padding[2];
        } UniformBufferObject;
        UniformBufferObject dummyUBO = { (float)tex_width, (float)tex_height, {0.0f, 0.0f} };

        // Push dummy uniform data onto the command buffer (for vertex shader UBO)
        // This pushes data into uniform slot 0 of the vertex stage.
        SDL_PushGPUVertexUniformData(cmd_buffer, 0, &dummyUBO, sizeof(dummyUBO));

        

        // Set up the color target info for the render pass.
        SDL_GPUColorTargetInfo color_target = {0};
        color_target.texture = swapchain_tex;
        color_target.mip_level = 0;
        color_target.layer_or_depth_plane = 0;
        color_target.clear_color = (SDL_FColor){ .r = 0.0f, .g = 0.0f, .b = 0.0f, .a = 0.5f };
        color_target.load_op = SDL_GPU_LOADOP_CLEAR;
        color_target.store_op = SDL_GPU_STOREOP_STORE;
        color_target.resolve_texture = NULL;
        color_target.cycle = false;
        color_target.cycle_resolve_texture = false;

        // Begin the render pass.
        SDL_GPURenderPass *render_pass = SDL_BeginGPURenderPass(cmd_buffer, &color_target, 1, NULL);
        if (!render_pass) {
            tklog_error("Failed to begin render pass: %s", SDL_GetError());
            return;
        }

        // Set the viewport to cover the entire swapchain texture.
        SDL_GPUViewport viewport = {
            .x = 0,
            .y = 0,
            .w = (float)tex_width,
            .h = (float)tex_height,
            .min_depth = 0.0f,
            .max_depth = 1.0f
        };
        tklog_scope(SDL_SetGPUViewport(render_pass, &viewport));

        // Bind the graphics pipeline.
        tklog_scope(SDL_BindGPUGraphicsPipeline(render_pass, p_graphics_pipeline->p_graphics_pipeline));

        // Bind the vertex buffer.
        SDL_GPUBufferBinding buffer_binding = { .buffer = gpu_buffer, .offset = 0 };
        tklog_scope(SDL_BindGPUVertexBuffers(render_pass, 0, &buffer_binding, 1));

        // Bind dummy textureâ€“sampler pairs for the fragment shader.
        SDL_GPUTextureSamplerBinding dummyTexBindings[8];
        for (int i = 0; i < 8; i++) {
            dummyTexBindings[i].texture = bitcoin_texture;
            dummyTexBindings[i].sampler = bitcoin_sampler;
        }
        SDL_BindGPUFragmentSamplers(render_pass, 0, dummyTexBindings, 8);

        tklog_scope(SDL_DrawGPUPrimitives(render_pass, 4, 2, 0, 0));

        // End the render pass.
        SDL_EndGPURenderPass(render_pass);

        // Submit the command buffer so that the commands are executed on the GPU.
        if (!SDL_SubmitGPUCommandBuffer(cmd_buffer)) {
            tklog_error("Failed to submit command buffer: %s", SDL_GetError());
            return;
        }

        // Optionally, delay to cap the frame rate (here ~60 FPS).
        // SDL_Delay(16);
    }

    tklog_scope(SDL_ReleaseGPUBuffer(p_gpu_device->p_gpu_device, gpu_buffer));
    // (Be sure to release/destroy your dummy resources when cleaning up.)
}
void cpi_Window_Destructor(
    void* p_void) 
{
    CPI_Window* p_window = (CPI_Window*)p_void;
    if (!p_window) {
        tklog_critical("NULL pointer");
        return;
    }
    if (!p_window->p_sdl_window) {
        tklog_critical("NULL pointer");
        return;
    }
    bool is_null = true;
    for (int i = 0; i < sizeof(CPI_ShadercCompiler); ++i) {
        if (((unsigned char*)p_window)[i] != 0) {
            is_null = false;
        }
    }
    if (is_null) {
        tklog_critical("shaderc compiler is null");
        return;
    }

    // getting gpu device
    /*
    tklog_scope(Vec** pp_gpu_device_vec = vec_MoveStart(g_vec));
    tklog_scope(int gpu_device_vec_index = vec_UpsertVecWithType_UnsafeWrite(*pp_gpu_device_vec, cpi_gpu_device_type));
    tklog_scope(vec_MoveToIndex(pp_gpu_device_vec, gpu_device_vec_index, cpi_gpu_device_type));
    tklog_scope(CPI_GPUDevice* p_gpu_device = vec_GetElement_UnsafeRead(*pp_gpu_device_vec, gpu_device_index, cpi_gpu_device_type));
    tklog_scope(if (!p_gpu_device->p_gpu_device) {
        tklog_critical("NULL pointer");
        exit(-1);
    });
    tklog_scope(SDL_ReleaseWindowFromGPUDevice(p_gpu_device->p_gpu_device, p_window->p_sdl_window));
    tklog_scope(vec_MoveEnd(pp_gpu_device_vec));
    */

    tklog_scope(SDL_DestroyWindow(p_window->p_sdl_window));
    memset(p_window, 0, sizeof(CPI_Window));
}
void cpi_Window_Destroy(
    int* p_window_index)
{
    if (!p_window_index) {
        tklog_critical("NULL pointer");
        return;
    }
    tklog_scope(Vec** pp_vec = vec_MoveStart(g_vec));
    tklog_scope(int window_vec_index = vec_GetVecWithType_UnsafeRead(*pp_vec, cpi_window_type));
    tklog_scope(vec_MoveToIndex(pp_vec, window_vec_index, cpi_window_type));
    tklog_scope(vec_SwitchReadToWrite(*pp_vec));
    tklog_scope(CPI_Window* p_window = (CPI_Window*)vec_GetElement_UnsafeRead(*pp_vec, *p_window_index, cpi_window_type));
    tklog_scope(cpi_Window_Destructor(p_window));
    tklog_scope(vec_SwitchWriteToRead(*pp_vec));
    tklog_scope(vec_MoveEnd(pp_vec));
    *p_window_index = 0;
    printf("SUCCESSFULLY destroyed window\n");
}
